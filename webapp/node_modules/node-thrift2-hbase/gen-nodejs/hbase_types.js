//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
"use strict";

var thrift = require('thrift');
var Thrift = thrift.Thrift;
var Q = thrift.Q;
var Int64 = require('node-int64');


var ttypes = module.exports = {};
ttypes.TDeleteType = {
  'DELETE_COLUMN' : 0,
  'DELETE_COLUMNS' : 1
};
ttypes.TDurability = {
  'SKIP_WAL' : 1,
  'ASYNC_WAL' : 2,
  'SYNC_WAL' : 3,
  'FSYNC_WAL' : 4
};
var TTimeRange = module.exports.TTimeRange = function(args) {
  this.minStamp = null;
  this.maxStamp = null;
  if (args) {
    if (args.minStamp !== undefined && args.minStamp !== null) {
      this.minStamp = args.minStamp;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field minStamp is unset!');
    }
    if (args.maxStamp !== undefined && args.maxStamp !== null) {
      this.maxStamp = args.maxStamp;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field maxStamp is unset!');
    }
  }
};
TTimeRange.prototype = {};
TTimeRange.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.minStamp = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.maxStamp = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TTimeRange.prototype.write = function(output) {
  output.writeStructBegin('TTimeRange');
  if (this.minStamp !== null && this.minStamp !== undefined) {
    output.writeFieldBegin('minStamp', Thrift.Type.I64, 1);
    output.writeI64(this.minStamp);
    output.writeFieldEnd();
  }
  if (this.maxStamp !== null && this.maxStamp !== undefined) {
    output.writeFieldBegin('maxStamp', Thrift.Type.I64, 2);
    output.writeI64(this.maxStamp);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TColumn = module.exports.TColumn = function(args) {
  this.family = null;
  this.qualifier = null;
  this.timestamp = null;
  if (args) {
    if (args.family !== undefined && args.family !== null) {
      this.family = args.family;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field family is unset!');
    }
    if (args.qualifier !== undefined && args.qualifier !== null) {
      this.qualifier = args.qualifier;
    }
    if (args.timestamp !== undefined && args.timestamp !== null) {
      this.timestamp = args.timestamp;
    }
  }
};
TColumn.prototype = {};
TColumn.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.family = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.qualifier = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.timestamp = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TColumn.prototype.write = function(output) {
  output.writeStructBegin('TColumn');
  if (this.family !== null && this.family !== undefined) {
    output.writeFieldBegin('family', Thrift.Type.STRING, 1);
    output.writeBinary(this.family);
    output.writeFieldEnd();
  }
  if (this.qualifier !== null && this.qualifier !== undefined) {
    output.writeFieldBegin('qualifier', Thrift.Type.STRING, 2);
    output.writeBinary(this.qualifier);
    output.writeFieldEnd();
  }
  if (this.timestamp !== null && this.timestamp !== undefined) {
    output.writeFieldBegin('timestamp', Thrift.Type.I64, 3);
    output.writeI64(this.timestamp);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TColumnValue = module.exports.TColumnValue = function(args) {
  this.family = null;
  this.qualifier = null;
  this.value = null;
  this.timestamp = null;
  this.tags = null;
  if (args) {
    if (args.family !== undefined && args.family !== null) {
      this.family = args.family;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field family is unset!');
    }
    if (args.qualifier !== undefined && args.qualifier !== null) {
      this.qualifier = args.qualifier;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field qualifier is unset!');
    }
    if (args.value !== undefined && args.value !== null) {
      this.value = args.value;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field value is unset!');
    }
    if (args.timestamp !== undefined && args.timestamp !== null) {
      this.timestamp = args.timestamp;
    }
    if (args.tags !== undefined && args.tags !== null) {
      this.tags = args.tags;
    }
  }
};
TColumnValue.prototype = {};
TColumnValue.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.family = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.qualifier = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.value = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I64) {
        this.timestamp = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRING) {
        this.tags = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TColumnValue.prototype.write = function(output) {
  output.writeStructBegin('TColumnValue');
  if (this.family !== null && this.family !== undefined) {
    output.writeFieldBegin('family', Thrift.Type.STRING, 1);
    output.writeBinary(this.family);
    output.writeFieldEnd();
  }
  if (this.qualifier !== null && this.qualifier !== undefined) {
    output.writeFieldBegin('qualifier', Thrift.Type.STRING, 2);
    output.writeBinary(this.qualifier);
    output.writeFieldEnd();
  }
  if (this.value !== null && this.value !== undefined) {
    output.writeFieldBegin('value', Thrift.Type.STRING, 3);
    output.writeBinary(this.value);
    output.writeFieldEnd();
  }
  if (this.timestamp !== null && this.timestamp !== undefined) {
    output.writeFieldBegin('timestamp', Thrift.Type.I64, 4);
    output.writeI64(this.timestamp);
    output.writeFieldEnd();
  }
  if (this.tags !== null && this.tags !== undefined) {
    output.writeFieldBegin('tags', Thrift.Type.STRING, 5);
    output.writeBinary(this.tags);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TColumnIncrement = module.exports.TColumnIncrement = function(args) {
  this.family = null;
  this.qualifier = null;
  this.amount = new Int64(1);
  if (args) {
    if (args.family !== undefined && args.family !== null) {
      this.family = args.family;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field family is unset!');
    }
    if (args.qualifier !== undefined && args.qualifier !== null) {
      this.qualifier = args.qualifier;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field qualifier is unset!');
    }
    if (args.amount !== undefined && args.amount !== null) {
      this.amount = args.amount;
    }
  }
};
TColumnIncrement.prototype = {};
TColumnIncrement.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.family = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.qualifier = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.amount = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TColumnIncrement.prototype.write = function(output) {
  output.writeStructBegin('TColumnIncrement');
  if (this.family !== null && this.family !== undefined) {
    output.writeFieldBegin('family', Thrift.Type.STRING, 1);
    output.writeBinary(this.family);
    output.writeFieldEnd();
  }
  if (this.qualifier !== null && this.qualifier !== undefined) {
    output.writeFieldBegin('qualifier', Thrift.Type.STRING, 2);
    output.writeBinary(this.qualifier);
    output.writeFieldEnd();
  }
  if (this.amount !== null && this.amount !== undefined) {
    output.writeFieldBegin('amount', Thrift.Type.I64, 3);
    output.writeI64(this.amount);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TResult = module.exports.TResult = function(args) {
  this.row = null;
  this.columnValues = null;
  if (args) {
    if (args.row !== undefined && args.row !== null) {
      this.row = args.row;
    }
    if (args.columnValues !== undefined && args.columnValues !== null) {
      this.columnValues = Thrift.copyList(args.columnValues, [ttypes.TColumnValue]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field columnValues is unset!');
    }
  }
};
TResult.prototype = {};
TResult.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.row = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        this.columnValues = [];
        var _rtmp31 = input.readListBegin();
        var _size0 = _rtmp31.size || 0;
        for (var _i2 = 0; _i2 < _size0; ++_i2) {
          var elem3 = null;
          elem3 = new ttypes.TColumnValue();
          elem3.read(input);
          this.columnValues.push(elem3);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TResult.prototype.write = function(output) {
  output.writeStructBegin('TResult');
  if (this.row !== null && this.row !== undefined) {
    output.writeFieldBegin('row', Thrift.Type.STRING, 1);
    output.writeBinary(this.row);
    output.writeFieldEnd();
  }
  if (this.columnValues !== null && this.columnValues !== undefined) {
    output.writeFieldBegin('columnValues', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.columnValues.length);
    for (var iter4 in this.columnValues) {
      if (this.columnValues.hasOwnProperty(iter4)) {
        iter4 = this.columnValues[iter4];
        iter4.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TAuthorization = module.exports.TAuthorization = function(args) {
  this.labels = null;
  if (args) {
    if (args.labels !== undefined && args.labels !== null) {
      this.labels = Thrift.copyList(args.labels, [null]);
    }
  }
};
TAuthorization.prototype = {};
TAuthorization.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        this.labels = [];
        var _rtmp36 = input.readListBegin();
        var _size5 = _rtmp36.size || 0;
        for (var _i7 = 0; _i7 < _size5; ++_i7) {
          var elem8 = null;
          elem8 = input.readString();
          this.labels.push(elem8);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TAuthorization.prototype.write = function(output) {
  output.writeStructBegin('TAuthorization');
  if (this.labels !== null && this.labels !== undefined) {
    output.writeFieldBegin('labels', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRING, this.labels.length);
    for (var iter9 in this.labels) {
      if (this.labels.hasOwnProperty(iter9)) {
        iter9 = this.labels[iter9];
        output.writeString(iter9);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TCellVisibility = module.exports.TCellVisibility = function(args) {
  this.expression = null;
  if (args) {
    if (args.expression !== undefined && args.expression !== null) {
      this.expression = args.expression;
    }
  }
};
TCellVisibility.prototype = {};
TCellVisibility.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.expression = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TCellVisibility.prototype.write = function(output) {
  output.writeStructBegin('TCellVisibility');
  if (this.expression !== null && this.expression !== undefined) {
    output.writeFieldBegin('expression', Thrift.Type.STRING, 1);
    output.writeString(this.expression);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TGet = module.exports.TGet = function(args) {
  this.row = null;
  this.columns = null;
  this.timestamp = null;
  this.timeRange = null;
  this.maxVersions = null;
  this.filterString = null;
  this.attributes = null;
  this.authorizations = null;
  if (args) {
    if (args.row !== undefined && args.row !== null) {
      this.row = args.row;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field row is unset!');
    }
    if (args.columns !== undefined && args.columns !== null) {
      this.columns = Thrift.copyList(args.columns, [ttypes.TColumn]);
    }
    if (args.timestamp !== undefined && args.timestamp !== null) {
      this.timestamp = args.timestamp;
    }
    if (args.timeRange !== undefined && args.timeRange !== null) {
      this.timeRange = new ttypes.TTimeRange(args.timeRange);
    }
    if (args.maxVersions !== undefined && args.maxVersions !== null) {
      this.maxVersions = args.maxVersions;
    }
    if (args.filterString !== undefined && args.filterString !== null) {
      this.filterString = args.filterString;
    }
    if (args.attributes !== undefined && args.attributes !== null) {
      this.attributes = Thrift.copyMap(args.attributes, [null]);
    }
    if (args.authorizations !== undefined && args.authorizations !== null) {
      this.authorizations = new ttypes.TAuthorization(args.authorizations);
    }
  }
};
TGet.prototype = {};
TGet.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.row = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        this.columns = [];
        var _rtmp311 = input.readListBegin();
        var _size10 = _rtmp311.size || 0;
        for (var _i12 = 0; _i12 < _size10; ++_i12) {
          var elem13 = null;
          elem13 = new ttypes.TColumn();
          elem13.read(input);
          this.columns.push(elem13);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.timestamp = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.timeRange = new ttypes.TTimeRange();
        this.timeRange.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I32) {
        this.maxVersions = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRING) {
        this.filterString = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.MAP) {
        this.attributes = {};
        var _rtmp315 = input.readMapBegin();
        var _size14 = _rtmp315.size || 0;
        for (var _i16 = 0; _i16 < _size14; ++_i16) {
          var key17 = null;
          var val18 = null;
          key17 = input.readBinary();
          val18 = input.readBinary();
          this.attributes[key17] = val18;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.STRUCT) {
        this.authorizations = new ttypes.TAuthorization();
        this.authorizations.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TGet.prototype.write = function(output) {
  output.writeStructBegin('TGet');
  if (this.row !== null && this.row !== undefined) {
    output.writeFieldBegin('row', Thrift.Type.STRING, 1);
    output.writeBinary(this.row);
    output.writeFieldEnd();
  }
  if (this.columns !== null && this.columns !== undefined) {
    output.writeFieldBegin('columns', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.columns.length);
    for (var iter19 in this.columns) {
      if (this.columns.hasOwnProperty(iter19)) {
        iter19 = this.columns[iter19];
        iter19.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.timestamp !== null && this.timestamp !== undefined) {
    output.writeFieldBegin('timestamp', Thrift.Type.I64, 3);
    output.writeI64(this.timestamp);
    output.writeFieldEnd();
  }
  if (this.timeRange !== null && this.timeRange !== undefined) {
    output.writeFieldBegin('timeRange', Thrift.Type.STRUCT, 4);
    this.timeRange.write(output);
    output.writeFieldEnd();
  }
  if (this.maxVersions !== null && this.maxVersions !== undefined) {
    output.writeFieldBegin('maxVersions', Thrift.Type.I32, 5);
    output.writeI32(this.maxVersions);
    output.writeFieldEnd();
  }
  if (this.filterString !== null && this.filterString !== undefined) {
    output.writeFieldBegin('filterString', Thrift.Type.STRING, 6);
    output.writeBinary(this.filterString);
    output.writeFieldEnd();
  }
  if (this.attributes !== null && this.attributes !== undefined) {
    output.writeFieldBegin('attributes', Thrift.Type.MAP, 7);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.attributes));
    for (var kiter20 in this.attributes) {
      if (this.attributes.hasOwnProperty(kiter20)) {
        var viter21 = this.attributes[kiter20];
        output.writeBinary(kiter20);
        output.writeBinary(viter21);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.authorizations !== null && this.authorizations !== undefined) {
    output.writeFieldBegin('authorizations', Thrift.Type.STRUCT, 8);
    this.authorizations.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TPut = module.exports.TPut = function(args) {
  this.row = null;
  this.columnValues = null;
  this.timestamp = null;
  this.attributes = null;
  this.durability = null;
  this.cellVisibility = null;
  if (args) {
    if (args.row !== undefined && args.row !== null) {
      this.row = args.row;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field row is unset!');
    }
    if (args.columnValues !== undefined && args.columnValues !== null) {
      this.columnValues = Thrift.copyList(args.columnValues, [ttypes.TColumnValue]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field columnValues is unset!');
    }
    if (args.timestamp !== undefined && args.timestamp !== null) {
      this.timestamp = args.timestamp;
    }
    if (args.attributes !== undefined && args.attributes !== null) {
      this.attributes = Thrift.copyMap(args.attributes, [null]);
    }
    if (args.durability !== undefined && args.durability !== null) {
      this.durability = args.durability;
    }
    if (args.cellVisibility !== undefined && args.cellVisibility !== null) {
      this.cellVisibility = new ttypes.TCellVisibility(args.cellVisibility);
    }
  }
};
TPut.prototype = {};
TPut.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.row = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        this.columnValues = [];
        var _rtmp323 = input.readListBegin();
        var _size22 = _rtmp323.size || 0;
        for (var _i24 = 0; _i24 < _size22; ++_i24) {
          var elem25 = null;
          elem25 = new ttypes.TColumnValue();
          elem25.read(input);
          this.columnValues.push(elem25);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.timestamp = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.MAP) {
        this.attributes = {};
        var _rtmp327 = input.readMapBegin();
        var _size26 = _rtmp327.size || 0;
        for (var _i28 = 0; _i28 < _size26; ++_i28) {
          var key29 = null;
          var val30 = null;
          key29 = input.readBinary();
          val30 = input.readBinary();
          this.attributes[key29] = val30;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.I32) {
        this.durability = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.STRUCT) {
        this.cellVisibility = new ttypes.TCellVisibility();
        this.cellVisibility.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TPut.prototype.write = function(output) {
  output.writeStructBegin('TPut');
  if (this.row !== null && this.row !== undefined) {
    output.writeFieldBegin('row', Thrift.Type.STRING, 1);
    output.writeBinary(this.row);
    output.writeFieldEnd();
  }
  if (this.columnValues !== null && this.columnValues !== undefined) {
    output.writeFieldBegin('columnValues', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.columnValues.length);
    for (var iter31 in this.columnValues) {
      if (this.columnValues.hasOwnProperty(iter31)) {
        iter31 = this.columnValues[iter31];
        iter31.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.timestamp !== null && this.timestamp !== undefined) {
    output.writeFieldBegin('timestamp', Thrift.Type.I64, 3);
    output.writeI64(this.timestamp);
    output.writeFieldEnd();
  }
  if (this.attributes !== null && this.attributes !== undefined) {
    output.writeFieldBegin('attributes', Thrift.Type.MAP, 5);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.attributes));
    for (var kiter32 in this.attributes) {
      if (this.attributes.hasOwnProperty(kiter32)) {
        var viter33 = this.attributes[kiter32];
        output.writeBinary(kiter32);
        output.writeBinary(viter33);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.durability !== null && this.durability !== undefined) {
    output.writeFieldBegin('durability', Thrift.Type.I32, 6);
    output.writeI32(this.durability);
    output.writeFieldEnd();
  }
  if (this.cellVisibility !== null && this.cellVisibility !== undefined) {
    output.writeFieldBegin('cellVisibility', Thrift.Type.STRUCT, 7);
    this.cellVisibility.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TDelete = module.exports.TDelete = function(args) {
  this.row = null;
  this.columns = null;
  this.timestamp = null;
  this.deleteType = 1;
  this.attributes = null;
  this.durability = null;
  if (args) {
    if (args.row !== undefined && args.row !== null) {
      this.row = args.row;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field row is unset!');
    }
    if (args.columns !== undefined && args.columns !== null) {
      this.columns = Thrift.copyList(args.columns, [ttypes.TColumn]);
    }
    if (args.timestamp !== undefined && args.timestamp !== null) {
      this.timestamp = args.timestamp;
    }
    if (args.deleteType !== undefined && args.deleteType !== null) {
      this.deleteType = args.deleteType;
    }
    if (args.attributes !== undefined && args.attributes !== null) {
      this.attributes = Thrift.copyMap(args.attributes, [null]);
    }
    if (args.durability !== undefined && args.durability !== null) {
      this.durability = args.durability;
    }
  }
};
TDelete.prototype = {};
TDelete.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.row = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        this.columns = [];
        var _rtmp335 = input.readListBegin();
        var _size34 = _rtmp335.size || 0;
        for (var _i36 = 0; _i36 < _size34; ++_i36) {
          var elem37 = null;
          elem37 = new ttypes.TColumn();
          elem37.read(input);
          this.columns.push(elem37);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.timestamp = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.deleteType = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.MAP) {
        this.attributes = {};
        var _rtmp339 = input.readMapBegin();
        var _size38 = _rtmp339.size || 0;
        for (var _i40 = 0; _i40 < _size38; ++_i40) {
          var key41 = null;
          var val42 = null;
          key41 = input.readBinary();
          val42 = input.readBinary();
          this.attributes[key41] = val42;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.I32) {
        this.durability = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TDelete.prototype.write = function(output) {
  output.writeStructBegin('TDelete');
  if (this.row !== null && this.row !== undefined) {
    output.writeFieldBegin('row', Thrift.Type.STRING, 1);
    output.writeBinary(this.row);
    output.writeFieldEnd();
  }
  if (this.columns !== null && this.columns !== undefined) {
    output.writeFieldBegin('columns', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.columns.length);
    for (var iter43 in this.columns) {
      if (this.columns.hasOwnProperty(iter43)) {
        iter43 = this.columns[iter43];
        iter43.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.timestamp !== null && this.timestamp !== undefined) {
    output.writeFieldBegin('timestamp', Thrift.Type.I64, 3);
    output.writeI64(this.timestamp);
    output.writeFieldEnd();
  }
  if (this.deleteType !== null && this.deleteType !== undefined) {
    output.writeFieldBegin('deleteType', Thrift.Type.I32, 4);
    output.writeI32(this.deleteType);
    output.writeFieldEnd();
  }
  if (this.attributes !== null && this.attributes !== undefined) {
    output.writeFieldBegin('attributes', Thrift.Type.MAP, 6);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.attributes));
    for (var kiter44 in this.attributes) {
      if (this.attributes.hasOwnProperty(kiter44)) {
        var viter45 = this.attributes[kiter44];
        output.writeBinary(kiter44);
        output.writeBinary(viter45);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.durability !== null && this.durability !== undefined) {
    output.writeFieldBegin('durability', Thrift.Type.I32, 7);
    output.writeI32(this.durability);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TIncrement = module.exports.TIncrement = function(args) {
  this.row = null;
  this.columns = null;
  this.attributes = null;
  this.durability = null;
  this.cellVisibility = null;
  if (args) {
    if (args.row !== undefined && args.row !== null) {
      this.row = args.row;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field row is unset!');
    }
    if (args.columns !== undefined && args.columns !== null) {
      this.columns = Thrift.copyList(args.columns, [ttypes.TColumnIncrement]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field columns is unset!');
    }
    if (args.attributes !== undefined && args.attributes !== null) {
      this.attributes = Thrift.copyMap(args.attributes, [null]);
    }
    if (args.durability !== undefined && args.durability !== null) {
      this.durability = args.durability;
    }
    if (args.cellVisibility !== undefined && args.cellVisibility !== null) {
      this.cellVisibility = new ttypes.TCellVisibility(args.cellVisibility);
    }
  }
};
TIncrement.prototype = {};
TIncrement.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.row = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        this.columns = [];
        var _rtmp347 = input.readListBegin();
        var _size46 = _rtmp347.size || 0;
        for (var _i48 = 0; _i48 < _size46; ++_i48) {
          var elem49 = null;
          elem49 = new ttypes.TColumnIncrement();
          elem49.read(input);
          this.columns.push(elem49);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.MAP) {
        this.attributes = {};
        var _rtmp351 = input.readMapBegin();
        var _size50 = _rtmp351.size || 0;
        for (var _i52 = 0; _i52 < _size50; ++_i52) {
          var key53 = null;
          var val54 = null;
          key53 = input.readBinary();
          val54 = input.readBinary();
          this.attributes[key53] = val54;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I32) {
        this.durability = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRUCT) {
        this.cellVisibility = new ttypes.TCellVisibility();
        this.cellVisibility.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TIncrement.prototype.write = function(output) {
  output.writeStructBegin('TIncrement');
  if (this.row !== null && this.row !== undefined) {
    output.writeFieldBegin('row', Thrift.Type.STRING, 1);
    output.writeBinary(this.row);
    output.writeFieldEnd();
  }
  if (this.columns !== null && this.columns !== undefined) {
    output.writeFieldBegin('columns', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.columns.length);
    for (var iter55 in this.columns) {
      if (this.columns.hasOwnProperty(iter55)) {
        iter55 = this.columns[iter55];
        iter55.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.attributes !== null && this.attributes !== undefined) {
    output.writeFieldBegin('attributes', Thrift.Type.MAP, 4);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.attributes));
    for (var kiter56 in this.attributes) {
      if (this.attributes.hasOwnProperty(kiter56)) {
        var viter57 = this.attributes[kiter56];
        output.writeBinary(kiter56);
        output.writeBinary(viter57);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.durability !== null && this.durability !== undefined) {
    output.writeFieldBegin('durability', Thrift.Type.I32, 5);
    output.writeI32(this.durability);
    output.writeFieldEnd();
  }
  if (this.cellVisibility !== null && this.cellVisibility !== undefined) {
    output.writeFieldBegin('cellVisibility', Thrift.Type.STRUCT, 6);
    this.cellVisibility.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TAppend = module.exports.TAppend = function(args) {
  this.row = null;
  this.columns = null;
  this.attributes = null;
  this.durability = null;
  this.cellVisibility = null;
  if (args) {
    if (args.row !== undefined && args.row !== null) {
      this.row = args.row;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field row is unset!');
    }
    if (args.columns !== undefined && args.columns !== null) {
      this.columns = Thrift.copyList(args.columns, [ttypes.TColumnValue]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field columns is unset!');
    }
    if (args.attributes !== undefined && args.attributes !== null) {
      this.attributes = Thrift.copyMap(args.attributes, [null]);
    }
    if (args.durability !== undefined && args.durability !== null) {
      this.durability = args.durability;
    }
    if (args.cellVisibility !== undefined && args.cellVisibility !== null) {
      this.cellVisibility = new ttypes.TCellVisibility(args.cellVisibility);
    }
  }
};
TAppend.prototype = {};
TAppend.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.row = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        this.columns = [];
        var _rtmp359 = input.readListBegin();
        var _size58 = _rtmp359.size || 0;
        for (var _i60 = 0; _i60 < _size58; ++_i60) {
          var elem61 = null;
          elem61 = new ttypes.TColumnValue();
          elem61.read(input);
          this.columns.push(elem61);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.MAP) {
        this.attributes = {};
        var _rtmp363 = input.readMapBegin();
        var _size62 = _rtmp363.size || 0;
        for (var _i64 = 0; _i64 < _size62; ++_i64) {
          var key65 = null;
          var val66 = null;
          key65 = input.readBinary();
          val66 = input.readBinary();
          this.attributes[key65] = val66;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.durability = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRUCT) {
        this.cellVisibility = new ttypes.TCellVisibility();
        this.cellVisibility.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TAppend.prototype.write = function(output) {
  output.writeStructBegin('TAppend');
  if (this.row !== null && this.row !== undefined) {
    output.writeFieldBegin('row', Thrift.Type.STRING, 1);
    output.writeBinary(this.row);
    output.writeFieldEnd();
  }
  if (this.columns !== null && this.columns !== undefined) {
    output.writeFieldBegin('columns', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.columns.length);
    for (var iter67 in this.columns) {
      if (this.columns.hasOwnProperty(iter67)) {
        iter67 = this.columns[iter67];
        iter67.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.attributes !== null && this.attributes !== undefined) {
    output.writeFieldBegin('attributes', Thrift.Type.MAP, 3);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.attributes));
    for (var kiter68 in this.attributes) {
      if (this.attributes.hasOwnProperty(kiter68)) {
        var viter69 = this.attributes[kiter68];
        output.writeBinary(kiter68);
        output.writeBinary(viter69);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.durability !== null && this.durability !== undefined) {
    output.writeFieldBegin('durability', Thrift.Type.I32, 4);
    output.writeI32(this.durability);
    output.writeFieldEnd();
  }
  if (this.cellVisibility !== null && this.cellVisibility !== undefined) {
    output.writeFieldBegin('cellVisibility', Thrift.Type.STRUCT, 5);
    this.cellVisibility.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TScan = module.exports.TScan = function(args) {
  this.startRow = null;
  this.stopRow = null;
  this.columns = null;
  this.caching = null;
  this.maxVersions = 1;
  this.timeRange = null;
  this.filterString = null;
  this.batchSize = null;
  this.attributes = null;
  this.authorizations = null;
  this.reversed = null;
  if (args) {
    if (args.startRow !== undefined && args.startRow !== null) {
      this.startRow = args.startRow;
    }
    if (args.stopRow !== undefined && args.stopRow !== null) {
      this.stopRow = args.stopRow;
    }
    if (args.columns !== undefined && args.columns !== null) {
      this.columns = Thrift.copyList(args.columns, [ttypes.TColumn]);
    }
    if (args.caching !== undefined && args.caching !== null) {
      this.caching = args.caching;
    }
    if (args.maxVersions !== undefined && args.maxVersions !== null) {
      this.maxVersions = args.maxVersions;
    }
    if (args.timeRange !== undefined && args.timeRange !== null) {
      this.timeRange = new ttypes.TTimeRange(args.timeRange);
    }
    if (args.filterString !== undefined && args.filterString !== null) {
      this.filterString = args.filterString;
    }
    if (args.batchSize !== undefined && args.batchSize !== null) {
      this.batchSize = args.batchSize;
    }
    if (args.attributes !== undefined && args.attributes !== null) {
      this.attributes = Thrift.copyMap(args.attributes, [null]);
    }
    if (args.authorizations !== undefined && args.authorizations !== null) {
      this.authorizations = new ttypes.TAuthorization(args.authorizations);
    }
    if (args.reversed !== undefined && args.reversed !== null) {
      this.reversed = args.reversed;
    }
  }
};
TScan.prototype = {};
TScan.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.startRow = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.stopRow = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        this.columns = [];
        var _rtmp371 = input.readListBegin();
        var _size70 = _rtmp371.size || 0;
        for (var _i72 = 0; _i72 < _size70; ++_i72) {
          var elem73 = null;
          elem73 = new ttypes.TColumn();
          elem73.read(input);
          this.columns.push(elem73);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.caching = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I32) {
        this.maxVersions = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRUCT) {
        this.timeRange = new ttypes.TTimeRange();
        this.timeRange.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.STRING) {
        this.filterString = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.I32) {
        this.batchSize = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.MAP) {
        this.attributes = {};
        var _rtmp375 = input.readMapBegin();
        var _size74 = _rtmp375.size || 0;
        for (var _i76 = 0; _i76 < _size74; ++_i76) {
          var key77 = null;
          var val78 = null;
          key77 = input.readBinary();
          val78 = input.readBinary();
          this.attributes[key77] = val78;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 10:
      if (ftype == Thrift.Type.STRUCT) {
        this.authorizations = new ttypes.TAuthorization();
        this.authorizations.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 11:
      if (ftype == Thrift.Type.BOOL) {
        this.reversed = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TScan.prototype.write = function(output) {
  output.writeStructBegin('TScan');
  if (this.startRow !== null && this.startRow !== undefined) {
    output.writeFieldBegin('startRow', Thrift.Type.STRING, 1);
    output.writeBinary(this.startRow);
    output.writeFieldEnd();
  }
  if (this.stopRow !== null && this.stopRow !== undefined) {
    output.writeFieldBegin('stopRow', Thrift.Type.STRING, 2);
    output.writeBinary(this.stopRow);
    output.writeFieldEnd();
  }
  if (this.columns !== null && this.columns !== undefined) {
    output.writeFieldBegin('columns', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.STRUCT, this.columns.length);
    for (var iter79 in this.columns) {
      if (this.columns.hasOwnProperty(iter79)) {
        iter79 = this.columns[iter79];
        iter79.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.caching !== null && this.caching !== undefined) {
    output.writeFieldBegin('caching', Thrift.Type.I32, 4);
    output.writeI32(this.caching);
    output.writeFieldEnd();
  }
  if (this.maxVersions !== null && this.maxVersions !== undefined) {
    output.writeFieldBegin('maxVersions', Thrift.Type.I32, 5);
    output.writeI32(this.maxVersions);
    output.writeFieldEnd();
  }
  if (this.timeRange !== null && this.timeRange !== undefined) {
    output.writeFieldBegin('timeRange', Thrift.Type.STRUCT, 6);
    this.timeRange.write(output);
    output.writeFieldEnd();
  }
  if (this.filterString !== null && this.filterString !== undefined) {
    output.writeFieldBegin('filterString', Thrift.Type.STRING, 7);
    output.writeBinary(this.filterString);
    output.writeFieldEnd();
  }
  if (this.batchSize !== null && this.batchSize !== undefined) {
    output.writeFieldBegin('batchSize', Thrift.Type.I32, 8);
    output.writeI32(this.batchSize);
    output.writeFieldEnd();
  }
  if (this.attributes !== null && this.attributes !== undefined) {
    output.writeFieldBegin('attributes', Thrift.Type.MAP, 9);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.attributes));
    for (var kiter80 in this.attributes) {
      if (this.attributes.hasOwnProperty(kiter80)) {
        var viter81 = this.attributes[kiter80];
        output.writeBinary(kiter80);
        output.writeBinary(viter81);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.authorizations !== null && this.authorizations !== undefined) {
    output.writeFieldBegin('authorizations', Thrift.Type.STRUCT, 10);
    this.authorizations.write(output);
    output.writeFieldEnd();
  }
  if (this.reversed !== null && this.reversed !== undefined) {
    output.writeFieldBegin('reversed', Thrift.Type.BOOL, 11);
    output.writeBool(this.reversed);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TMutation = module.exports.TMutation = function(args) {
  this.put = null;
  this.deleteSingle = null;
  if (args) {
    if (args.put !== undefined && args.put !== null) {
      this.put = new ttypes.TPut(args.put);
    }
    if (args.deleteSingle !== undefined && args.deleteSingle !== null) {
      this.deleteSingle = new ttypes.TDelete(args.deleteSingle);
    }
  }
};
TMutation.prototype = {};
TMutation.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.put = new ttypes.TPut();
        this.put.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.deleteSingle = new ttypes.TDelete();
        this.deleteSingle.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TMutation.prototype.write = function(output) {
  output.writeStructBegin('TMutation');
  if (this.put !== null && this.put !== undefined) {
    output.writeFieldBegin('put', Thrift.Type.STRUCT, 1);
    this.put.write(output);
    output.writeFieldEnd();
  }
  if (this.deleteSingle !== null && this.deleteSingle !== undefined) {
    output.writeFieldBegin('deleteSingle', Thrift.Type.STRUCT, 2);
    this.deleteSingle.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TRowMutations = module.exports.TRowMutations = function(args) {
  this.row = null;
  this.mutations = null;
  if (args) {
    if (args.row !== undefined && args.row !== null) {
      this.row = args.row;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field row is unset!');
    }
    if (args.mutations !== undefined && args.mutations !== null) {
      this.mutations = Thrift.copyList(args.mutations, [ttypes.TMutation]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field mutations is unset!');
    }
  }
};
TRowMutations.prototype = {};
TRowMutations.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.row = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        this.mutations = [];
        var _rtmp383 = input.readListBegin();
        var _size82 = _rtmp383.size || 0;
        for (var _i84 = 0; _i84 < _size82; ++_i84) {
          var elem85 = null;
          elem85 = new ttypes.TMutation();
          elem85.read(input);
          this.mutations.push(elem85);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TRowMutations.prototype.write = function(output) {
  output.writeStructBegin('TRowMutations');
  if (this.row !== null && this.row !== undefined) {
    output.writeFieldBegin('row', Thrift.Type.STRING, 1);
    output.writeBinary(this.row);
    output.writeFieldEnd();
  }
  if (this.mutations !== null && this.mutations !== undefined) {
    output.writeFieldBegin('mutations', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.mutations.length);
    for (var iter86 in this.mutations) {
      if (this.mutations.hasOwnProperty(iter86)) {
        iter86 = this.mutations[iter86];
        iter86.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TIOError = module.exports.TIOError = function(args) {
  Thrift.TException.call(this, "TIOError");
  this.name = "TIOError";
  this.message = null;
  if (args) {
    if (args.message !== undefined && args.message !== null) {
      this.message = args.message;
    }
  }
};
Thrift.inherits(TIOError, Thrift.TException);
TIOError.prototype.name = 'TIOError';
TIOError.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.message = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TIOError.prototype.write = function(output) {
  output.writeStructBegin('TIOError');
  if (this.message !== null && this.message !== undefined) {
    output.writeFieldBegin('message', Thrift.Type.STRING, 1);
    output.writeString(this.message);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TIllegalArgument = module.exports.TIllegalArgument = function(args) {
  Thrift.TException.call(this, "TIllegalArgument");
  this.name = "TIllegalArgument";
  this.message = null;
  if (args) {
    if (args.message !== undefined && args.message !== null) {
      this.message = args.message;
    }
  }
};
Thrift.inherits(TIllegalArgument, Thrift.TException);
TIllegalArgument.prototype.name = 'TIllegalArgument';
TIllegalArgument.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.message = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TIllegalArgument.prototype.write = function(output) {
  output.writeStructBegin('TIllegalArgument');
  if (this.message !== null && this.message !== undefined) {
    output.writeFieldBegin('message', Thrift.Type.STRING, 1);
    output.writeString(this.message);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

